title: Das kleine Einmaleins von git
description: |
  Wir lernen die allergrundlegendsten git-Kommandos kennen und probieren sie aus.
timevalue: 1.0
difficulty: 1
requires: GitLab
---

In diesem Abschnitt widmen wir uns dem Versionskontrollsystem (engl. Version control system, kurz vcs) Git. Dieses bildet quasi die Grundlage unseres Programmierpraktikums, da alle Abgaben über ebendieses vcs erfolgen müssen.
Software wie git erleichtert aber auch sonst den Programmier- und allgemeinen Entwicklungsalltag. Recht einfach können mehrere Entwickler zusammen an der gleichen Codebasis arbeiten, Änderungen in den vorhandenen Code einpflegen oder auch mal auf eine frühere Version zurückspringen. Die wirklichen Möglichkeiten von Git gehen natürlich weit über die genannten Beispiele hinaus, aber würden dementsprechend auch den Rahmen dieses Kapitels sprengen.

Zuallererst beschäftigen wir uns mit den wichtigsten Grundlagen. Git in seiner eigentlichen Form ist ein reines Kommandozeilenprogramm, zwar gibt es inzwischen auch GUIs für Git, der Einfachheit halber beschäftigen wir uns aber hier nur mit der CLI-Version.

Als Server gibt es inzwischen viele bekannte, größtenteils kostenlose, Websites wie z.B. GitHub, GitLab, GitTea oder BitBucket.

Wie funktioniert eigentlich git? Dafür verweisen wir an dieser Stelle auf eine externe Quelle, schauen Sie sich diese in Ruhe an und kehren sie dann hierher zurück, wenn Sie bis zum Abschnit x gekommen sind.

Nun aber zum Anwenden von Git.
Als Startpunkt jedes Git-Repositories steht die Initialisierung. Dafür navigieren wir mit unserem Terminal in einen leeren Ordner, welchen wir als Git Repo benutzen möchten und führen den Befehl `git init` aus. Dieser erzeugt einen unsichtbaren Ordner namens `.git`, in dem alle für Git wichtigen Metadaten gespeichert werden. Wird dieser Ordner gelöscht, sind sämtliche im Repo gespeicherte lokale Informationen verloren.
Nun können wir in diesem Ordner unsere ersten Dateien anlegen. Meistens wird eine sogenannte `README.md` Datei angelegt, welche von den Web-Frontends der Git Server standardmäßig beim Aufrufen des Repositories angezeigt wird.
Legen auch Sie eine Datei namens `README.md` in ihrem Repository an und beschreiben sie kurz ihr Projekt indem sie ihm den Titel Programmierpraktikum geben und ihren Namen sowie den Namen ihres Tutors vermerken.
Als nächstes müssen wir Git noch erklären, dass wir diese Datei beim nächsten Hochschieben (pushen) auf den Git Server mitsenden möchten. Dazu müssen wir die Datei, bzw. Bei bereits existierenden Dateien deren änderungen, unserem Git repo hinzufügen/adden. Dafür nutzen wir den Befehl `git add` und hängen unseren Dateinamen an, in unserem Fall also `git add README.me`.
Jetzt weiß unser Repo schon einmal, dass die Datei existiert und kennt den aktuellen Inhalt der Datei. Allerdings müssen wir jetzt noch diese Datei bzw. Die Änderungen am Repo übergeben/commiten damit Git weiß, welche Änderungen beim nächsten push gesendet werden. Dazu nutzen wir den Befehl `git commit`. Damit man auf die schnelle sieht, welche Änderungen der letzte Commit enthalten hat, geben wir dem ganzen noch eine kurze Beschreibung dazu, meistens auf Englisch, das steht uns in diesem Fall aber natürlich frei.
Diese Nachricht lässt sich ganz einfach mit dem zusätzlichen Parameter `-m`/`--message` anhängen. So könnten wir zum Beispiel `git commit -m “Readme hinzugefügt"` schreiben.
Wenn wir dann unsere Änderungen an den Server schicken, würde nun im Webinterface die Datei und in der Versionshistorie die Nachricht “Readme hinzugefügt” sichtbar sein.
Allerdings weiß Git ja noch gar nicht, wohin das alles geschickt werden soll. Dazu müssen wir in den Metadaten unseres Repositories noch eine sogenannte Remote URL hinzufügen. Also die Adresse unseres Servers an der das Propra-Repo liegt.
Praktischerweise bietet der Fachbereich unter der Adresse https://git.imp.fu-berlin.de/ einen FU gehosteten GitLab Server an, auf welchem wir unser ProPra-Repo anlegen können.
Nachdem wir uns mit unserem Zedat-Login angemeldet haben, erstellen wir mit einem Klick auf “Neues Projekt”/”New project” ein neues leeres Repository. Als namen verwenden wir schlicht propa, die Sichtbarkeit stellen wir auf Privat und natürlich legen wir das Projekt **ohne* Readme an, wir haben ja schon eine.
Jetzt können wir auch endlich den Remote unseres GitLab Projekts zu unserem lokalen Repo hinzufügen. Wie Ihnen vielleicht auch schon aufgefallen ist, werden die Schritte dazu teilweise auch in Ihrem noch leeren Projekt unter “Push an existing Git repository” angegeben:

```bash
cd existing_repo
git remote rename origin old-origin
git remote add origin git@git.imp.fu-berlin.de:ihr-zedat-username/propra.git
git push -u origin --all
git push -u origin --tags
```

So oder so ähnlich sehen die notwendigen Schritte auch aus. Was diese denn nun tun, werden sie als Teil der Abgabe für diese Aufgabe erklären.

Wenn Sie jetzt die GitLab-Seite ihres Projekts neu laden, werden Sie sehen, dass sich einiges verändert hat. Sie sollten nun eine Verzeichnisansicht sehen und genau eine Datei, nämlich ihre `README.md`, deren Inhalt direkt darunter dargestellt werden sollte.

Bis hier hin sollten sie also jetzt verstanden haben wie Sie:

- Ein Git Repository initialisieren
- Eine Datei oder Änderungen an einer Datei dem aktuellen Stand hinzufügen
- Einen Git Commit erstellen und diesem eine Commit-Nachricht hinzufügen
- Den aktuellen Repository-Zustand zum Git-Server schicken

Wenn irgendetwas davon noch nicht klar sein sollte, gehen sie noch einmal die bis hierher genutzten Befehle durch und recherchieren sie, welche ihnen unklar sind. Häufig reicht es einfach, den unbekannten Befehl einmal in die Suchmaschine ihrer Wahl zu kopieren. 
So liefert z.B. die Suche nach `git push` viele Verschiedene Erklärungen zu diesem Befehl und seiner Nutzung.


!!! submission
    Die deliverables dürften meist einfach sein und aus dem passenden Output
    irgendwelcher git-Kommandos bestehen.

!!! warning
    Git ist extrem leistungsfähig, aber es kommt sehr oft auf's Detail an.
    Bitte sehr sorgfältig lesen und arbeiten, sonst kann es schnell frustrierend werden.

- Konzepte: Folge von Schnappschüssen eines Dateibaums, Verkettung mit Vorgängern, 
  Metadaten (Autor, Zeitstempel, Hash), Eigenschaften von Commit-Hashes
- `git status` und `git diff`
- `git add` und der Index als "Schmierzettel" für den nächsten Commit
- `git commit -m`
- `git log`
- `git push`
- Jetzt auf dem Gitlab-Server eine Änderung machen
- `git pull`

[HINT::Hinweis zur Praktikabilität]
  `git push` kann einem ganz schön auf die Nerven gehen, wenn man keinen
  `ssh-agent` laufen hat.
[ENDHINT]

!!! instructor
    Nur prüfen, ob der Commit ungefähr wie gewünscht aussieht.

Jetzt probieren wir noch die Macros für die Linkerzeugung aus:

- TA0::GitLab --> [TA0::GitLab] 
- TA1::GitLab --> [TA1::GitLab] 
- TA2::GitLab::mein Linktext --> [TA2::GitLab::mein Linktext] 
- TG0::ide --> [TG0::ide] 
- TG1::ide --> [TG1::ide] 
- TG2::ide::anderer Linktext --> [TG2::ide::anderer Linktext] 
- CH0::basis --> [CH0::basis] 
- CH1::basis --> [CH1::basis] 
- CH2::basis::mein Linktext --> [CH2::basis::mein Linktext] 
