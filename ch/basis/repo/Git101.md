title: Das kleine Einmaleins von Git
description: |
  grundlegende Git-Kommandos kennenlernen und ausprobieren
timevalue: 1.0
difficulty: 1
requires: GitLab
---

In diesem Abschnitt widmen wir uns dem Versionskontrollsystem (engl. Version control
system, kurz vcs) Git. Dieses bildet dahingehend die strukturelle Grundlage unseres
Programmierpraktikums, dass alle Abgaben über eben dieses vcs erfolgen müssen.
Software wie Git erleichtert aber auch sonst den Programmier- und allgemeinen
Entwicklungsalltag. Mehrere Entwickler können damit zusammen an demselben Projekt
arbeiten. Neben der Behandlung gleichzeitiger Änderungen in den vorhandenen Code
ergeben sich auch Möglichkeiten wie die Betrachtung einer frühere Version und damit dem
Nachverfolgen von Änderungen inklusive der entsprechenden Autoren.

Git ist zunächst einmal ein reines Kommandozeilenprogramm. Es gibt auch GUIs und insbesondere
Entwicklungsumgebungen, welche die direkte Verwendung erleichtern, aber zu Lehrzwecken liegt
der Fokus hier auf der direkten Verwendung des Kommandozeilenprogramms.

<!--Als Server gibt es inzwischen viele bekannte, größtenteils kostenlose, Websites wie z.B. GitHub, GitLab, GitTea oder BitBucket.-->

Wie funktioniert eigentlich Git? Dafür verweisen wir an dieser Stelle auf eine externe Quelle, schauen Sie sich diese in Ruhe an und kehren sie dann hierher zurück, wenn Sie bis zum Abschnit x gekommen sind.

Als Startpunkt jedes Git-Repos steht die Initialisierung. Dafür navigieren wir mit unserem Terminal in einen leeren Ordner, welchen wir als Git-Repo benutzen möchten, und führen den Befehl `git init` aus. Dieser erzeugt ein verstecktes Verzeichnis namens ".git", in dem alle für Git wichtigen Metadaten gespeichert werden. Wird dieser Ordner gelöscht, sind sämtliche im Repo gespeicherte lokale Informationen verloren.

Nun können wir in diesem Ordner unsere ersten Dateien anlegen. Meistens wird eine Datei namens "README.md" angelegt, welche von den Web-Frontends der Git-Server standardmäßig beim Aufrufen des Repos angezeigt wird.

Legen auch Sie eine solche Datei in ihrem Repo an und beschreiben Sie kurz Ihr Projekt, indem Sie ihm den Titel Programmierpraktikum geben und ihren Namen sowie den Namen ihres Tutors vermerken. Solange diese Informationen vorhanden sind, steht Ihnen frei, den Inhalt weitergehend zu gestalten.

Als nächstes müssen wir Git noch erklären, dass wir diese Datei beim nächsten Aufruf von `git push` auf den Git-Server mitsenden möchten.
Um Änderungen an Dateien (und das umfasst auch das Anlegen) hierfür vorzumerken, verwenden wir den Befehl `git add` und hängen unseren _vollständigen_ Dateinamen an, in unserem Fall also `git add README.md`.

Jetzt weiß unser Repo schon einmal, dass die Datei existiert und kennt ihren aktuellen Inhalt. Anschließend müssen wir die ausgewählten Änderungen in einem sogenannten Commit festhalten, damit Git weiß, welche Änderungen beim nächsten Push gesendet werden. Dazu nutzen wir den Befehl `git commit`. Damit man auf die schnelle sieht, welche Änderungen der letzte Commit enthalten hat, geben wir dem ganzen noch eine kurze Beschreibung dazu, meistens auf Englisch, das steht uns in diesem Fall aber natürlich frei.
Diese Nachricht lässt sich ganz einfach mit dem zusätzlichen Parameter `-m`/`--message` anhängen. So könnten wir zum Beispiel `git commit -m “Readme hinzugefügt"` schreiben.

Wenn wir dann unsere Änderungen an den Server schicken, würde nun im Webinterface die Datei und in der Versionshistorie die Nachricht “Readme hinzugefügt” sichtbar sein.
Allerdings weiß Git noch gar nicht, wohin das alles geschickt werden soll. Dazu müssen wir in den Metadaten unseres Repos noch eine sogenannte "Remote URL" hinzufügen, also die Adresse unseres Servers, auf dem das Propra-Repo liegt.

Der <!--dept-->Fachbereich Mathematik und Informatik der Freien Universität Berlin bietet unter der Adresse https://git.imp.fu-berlin.de/ einen GitLab-Server an, auf welchem wir unser ProPra-Repo ablegen können.
Nachdem wir uns mit unserem Zedat-Login angemeldet haben, erstellen wir mit einem Klick auf “Neues Projekt”/”New project” ein neues leeres Repo. Als Namen verwenden wir schlicht "propa", die Sichtbarkeit stellen wir auf Privat und natürlich legen wir das Projekt **ohne** Readme an, wir haben ja schon eine.
Jetzt können wir auch endlich den Remote unseres GitLab-Projekts zu unserem lokalen Repo hinzufügen. Wie Ihnen vielleicht auch schon aufgefallen ist, werden die Schritte dazu teilweise auch in Ihrem noch leeren Projekt unter “Push an existing Git repository” angegeben:

```bash
cd existing_repo
git remote rename origin old-origin
git remote add origin git@git.imp.fu-berlin.de:ihr-zedat-username/propra.git
git push -u origin --all
git push -u origin --tags
```

So oder so ähnlich sehen die notwendigen Schritte auch aus. Was diese im Detail tun, werden Sie als Teil der Abgabe für diese Aufgabe erklären.

Wenn Sie jetzt die GitLab-Seite ihres Projekts neu laden, werden Sie sehen, dass sich einiges verändert hat. Sie sollten nun eine Verzeichnisansicht sehen und genau eine Datei, nämlich ihre "README.md", deren Inhalt direkt darunter dargestellt werden sollte.

Bis hierhin sollten sie also jetzt verstanden haben, wie Sie:

- Ein Git-Repo initialisieren
- Eine Datei oder Änderungen an einer Datei dem aktuellen Stand hinzufügen
- Einen Commit erstellen und diesem eine Commit-Nachricht hinzufügen
- Den aktuellen Repo-Zustand zum Git-Server schicken

Wenn irgendetwas davon noch nicht klar sein sollte, gehen Sie noch einmal die bis hierher genutzten Befehle durch und recherchieren sie, welche Ihnen unklar sind. Häufig reicht es einfach, den unbekannten Befehl einmal in die Suchmaschine Ihrer Wahl zu kopieren. 
So liefert z.B. die Suche nach "git push" viele verschiedene Erklärungen zu diesem Befehl und seiner Nutzung.


!!! submission
    Die deliverables dürften meist einfach sein und aus dem passenden Output
    irgendwelcher git-Kommandos bestehen.

!!! warning
    Git ist extrem leistungsfähig, aber es kommt sehr oft aufs Detail an.
    Bitte sehr sorgfältig lesen und arbeiten, sonst kann es schnell frustrierend werden.

- Konzepte: Folge von Schnappschüssen eines Dateibaums, Verkettung mit Vorgängern, 
  Metadaten (Autor, Zeitstempel, Hash), Eigenschaften von Commit-Hashes
- `git status` und `git diff`
- `git add` und der Index als "Schmierzettel" für den nächsten Commit
- `git commit -m`
- `git log`
- `git push`
- Jetzt auf dem Gitlab-Server eine Änderung machen
- `git pull`

[HINT::Hinweis zur Praktikabilität]
  `git push` kann einem ganz schön auf die Nerven gehen, wenn man keinen
  `ssh-agent` laufen hat.
[ENDHINT]

!!! instructor
    Nur prüfen, ob der Commit ungefähr wie gewünscht aussieht.

Jetzt probieren wir noch die Macros für die Linkerzeugung aus:

- TA0::GitLab --> [TA0::GitLab] 
- TA1::GitLab --> [TA1::GitLab] 
- TA2::GitLab::mein Linktext --> [TA2::GitLab::mein Linktext] 
- TG0::ide --> [TG0::ide] 
- TG1::ide --> [TG1::ide] 
- TG2::ide::anderer Linktext --> [TG2::ide::anderer Linktext] 
- CH0::basis --> [CH0::basis] 
- CH1::basis --> [CH1::basis] 
- CH2::basis::mein Linktext --> [CH2::basis::mein Linktext] 
