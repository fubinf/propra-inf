title: git-102
stage: draft
timevalue: 2
difficulty: 3
explains:
assumes: git-Funktionsweise
requires: git-Zweitrepo
---

[SECTION::goal::experience]

Ich lerne wie die Grundfunktionen von git funktionieren und bekomme ein gefestigtes Verständnis 
von deren mentalem Modell.
[ENDSECTION]

[SECTION::background::default]

In [PARTREF::Git101] haben wir gerade so das Nötigste gelernt, um unsere Aufgaben im ProPra 
abzugeben. Jetzt geht es darum, das gelernte zu vertiefen und das Wissen um die Befehle und 
[PARTREF::git-Funktionsweise] zu festigen.

[ENDSECTION]

[SECTION::instructions::detailed]

In dieser Aufgabe werden wir so richtig tief in die interna von git einsteigen. Wie verwaltet 
git Dateien und Commits? Wie können wir diese vergleichen und uns einen überblick verschaffen 
was zu Lebzeiten eines Projektes eigentlich so passiert.

Damit wir aber nicht einfach nur dröge die Befehle herunter rattern werden wir das ganze anhand 
eines kleinen Beispiel-"Programms" abarbeiten. Hierzu schreiben wir ein paar Zeilen für einen 
hypothetischen Taschenrechner.

Wir gehen davon aus, das Sie bereits [PARTREF::git-Zweitrepo] erledigt und entsprechend ein 
neues und sauberes Repo bereit haben in welchem Sie sich ungehindert auslassen können.

Falls Sie diese Aufgabe übersprungen haben legen Sie einfach ein neues Verzeichnis außerhalb 
ihres ProPra-Repos und führen Sie den `git init` Befehl aus. Da wir in dieser ausgabe nicht `git 
push` oder `git pull` brauchen werden brauchen Sie auch kein neues Repo bei GitLab o.Ä. git Servern 
anlegen.

Was tut git init? Um das zu verstehen haben wir einen nützlichen Hilfsbefehl. Nämlich `git help`.
Dieser gibt uns ausführliche Dokumentation zu praktisch jedem git-Befehl, Begriff oder Konzept aus.
Führen wir nur `git help` aus erhalten wir eine kurz liste an gängigen git-Befehlen, dann eine 
längere mit noch mehr Befehlen und ganz unten steht noch ein weiterer nützlicher Hinweis.

```
'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help <command>' or 'git help <concept>'
to read about a specific subcommand or concept.
```

Wir wollen jetzt lernen was git init tut. Führen Sie also den `git help` Befehl für `git init` 
aus und beantworten Sie: 

[EQ] Was macht der Befehl `git init`? Referenzieren Sie hierbei die git Hilfe und vor allem die 
Teile die Sie verstehen.

[NOTICE]
Zu Beginn wird sehr vieles in der git-Hilfe deutlich ihren Kenntnisstand übersteigen und 
vielleicht etwas überwältigend wirken. Aber wie so oft, hilft es erst einmal alles auszublenden, 
was für die aktuelle Aufgabe irrelevant ist. Nach und nach werden Sie genug Wissen akquirieren, um 
auch kompliziertere Erklärungen zu verstehen.

Die gleichen Inhalte lassen sich übrigens auch im Browser in der [git Referenz](https://git-scm.
com/docs) nachschlagen.
[ENDNOTICE]

In der Dokumentation zu `git init` werden ihnen sicherlich der `.git` Ordner sowie die "Objekte" 
aufgefallen sein. Damit wir verstehen wozu diese da sind lesen wir den Abschnitt [Creating a Git 
repository](https://git-scm.com/docs/gitcore-tutorial) im `gitcore-tutorial`.

[EQ] Wie heisst der default Branch von git? Kann ich diesen umbenennen und brauche ich ihn 
überhaupt?
[EQ] Wodurch werden git-Objekte referenziert? 

Nun haben wir also ein neues und sauberes git Repo und haben verstanden, was sich bis dato darin 
befindet. Wenn wir jetzt `git status` ausführen, werden wir schlicht "No commits yet" angezeigt 
bekommen. Damit wir ein bisschen an echten Daten herumspielen können brauchen wir also erstmal 
überhaupt ebensolche in unserem Repository. Beginnen wir also mit unserem fiktiven Grundgerüst, der 
Funktionsdefinition:

```python
# Ein einfacher Rechner

def addiere(a, b):

```

Erstellen Sie die Datei `calculator.py` mit dem obigen Inhalt.
Führen sie doch mal `git status` aus. 

```
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	calculator.py

nothing added to commit but untracked files present (use "git add" to track)
```

Hier sehen wir jetzt einige Neue informationen. Zum einen bekommen wir noch immer "No commits 
yet" angezeigt. Was ja auch stimmt, denn wir haben lediglich eine neue Datei angelegt. Zumindest 
scheint git aber *irgendwas* über diese Datei zu wissen, denn sie wird als "Untracked file" 
angegeben.

Aber weiß git auch was sich in dieser Datei befindet? Die letzte Zeile gibt uns einen kleinen 
Hinweis. Git erfasst nämlich erst den Inhalt, wenn wir die Datei mit `git add` zum *Tracken* 
markieren.

Fügen Sie also jetzt die Datei der Staging-Area hinzu und prüfen Sie wieder den Status.
Welche Veränderung stellen Sie fest?

Soweit die Praxis, jetzt wieder ein bisschen Theorie.
Lesen Sie den Artikel [What really happens when I do git add.](https://medium.com/@raffs.
os/what-really-happens-when-i-do-git-add-8af29c1ec903)

Wir sollten jetzt ein Verständnis dafür haben, was der git-Index ist, was Objekte sind, welche 
Objekttypen es gibt und was passiert, wenn wir mit `git add` eine Datei zum Index hinzufügen.
Dazu ein paar Verständnisfragen:

[EQ] Speichert git erst beim Commiten Änderungen an einer Datei, oder schon vorher?
[EQ] Wo speichert git die Metadaten über eine Datei und wo die Inhalte?

Jetzt schauen wir uns einen neuen sehr nützlichen Befehl an, nämlich `git diff`.
Was tut `git diff`? Rufen Sie doch nochmal die Dokumentation zum Befehl auf.

Das ist richtig viel Stoff!
Das meiste davon interessiert uns aber gar nicht.

Es gibt jedoch einen Abschnitt, den wir uns mal ansehen sollten. Nämlich die *Examples*. Diese 
befinden sich ganz am Ende der Dokumentation. Darin sehen wir, direkt zu Beginn, folgende paar 
Beispiele:

```
EXAMPLES
       Various ways to check your working tree

               $ git diff            (1)
               $ git diff --cached   (2)
               $ git diff HEAD       (3)
               $ git diff AUTO_MERGE (4)

           1.   Changes in the working tree not yet staged for
                the next commit.
           2.   Changes between the index and your last commit;
                what you would be committing if you run git
                commit without -a option.
           3.   Changes in the working tree since your last
                commit; what you would be committing if you run
                git commit -a
           4.   Changes in the working tree you’ve made to
                resolve textual conflicts so far.
```

Das sieht doch schon um einiges Verständlicher aus. Aktuell interessiert uns nur Beispiel 1.
Führen wir es doch mal aus und gucken was passiert.

[EQ] Was gibt `git diff` jetzt und warum aus? (nichts, weil wir working tree und index 
vergleichen und es keine veränderungen gibt)

Erweitern wir nun unsere Additionsfunktion:

```python
# Ein einfacher Rechner
def addiere(a, b):
    # Diese Funktion addiert zwei Zahlen
    return a + b

```

Und führen Sie nochmal `git diff` aus.
Jetzt haben wir endlich eine Ausgabe!
Wenn wir jetzt auch nochmal `git status` ausführen, schließt sich der Kreis.

```
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   calculator.py

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   calculator.py
```

Wir können jetzt also folgendes feststellen: 

1. Wir haben noch immer keine Commits erzeugt.
2. Wir haben Änderungen/Neue Dateien zum Commiten vorgemerkt.
3. Wir haben weitere Änderungen an dieser neuen Datei vorgenommen seitdem wir Sie zum Commiten 
   vorgemerkt haben.
4. Git gibt uns hilfreiche Tips für Befehle welche wir evtl. gebrauchen könnten. 

[EQ] Welche Befehle sind das und was tun sie?

Fügen Sie die Änderungen an der datei `calculator.py` ebenfalls der Staging-Area hinzu.

[EQ] könnten wir jetzt nochmal zum vorherigen Status der Datei zurückkehren? (es kommt drauf an, 
es gibt evtl. wege mit git fsck, aber grundsätzlich sollte man davon ausgehen, dass alles was 
nicht commitet wurde weg ist, wenn es mit einem weitern git add in der staging area 
überschrieben wird)

Als Letztes schnüren Sie alles zu einem neuen Commit mit einer sinnvollen Commit-Nachricht.

[EQ] Was passiert nun im Hintergrund? (git sammelt alle referenzen zu den blobs und schnürt ein 
neues commit-Objekt)

Erweitern wir wieder unseren Taschenrechner, diesmal mit einer Funktionsdefinition für eine 
Multiplikationsfunktion:

```python
# Ein einfacher Rechner
def addiere(a, b):
    # Diese Funktion addiert zwei Zahlen
    return a + b

def multipliziere(a, b):

```

Diese neuen Änderungen fügen wir jetzt wieder dem Index hinzu und nehmen dann direkt weitere 
Änderungen vor:

```python
# Ein einfacher Rechner
def addiere(a, b):
    # Diese Funktion addiert zwei Zahlen
    return a + b

def multipliziere(a, b):
    # Diese Funktion multipliziert zwei Zahlen
    return a * b

```

Ohne diese Änderungen dem Index hinzuzufügen, können wir jetzt wieder einen näheren Blick auf 
`git diff` werfen um zu verstehen welche verschiedenen Optionen uns im Alltag nützlich werden 
können. 

Schauen Sie sich also wieder die Beispiele in der `git diff` Dokumentation und probieren Sie 
folgende Szenarios durch:

[EC] Vergleichen Sie den aktuellen Zustand der Datei mit den bereits vorgemerkten Änderungen. 
(`git diff`)
[EC] Vergleichen Sie die vorgemerkten Änderungen mit dem letzten Commit-Zustand. (`git diff 
--cached`)
[EC] Vergleichen Sie den aktuellen mit dem letzten Commit-Zustand. (`git diff HEAD`)

Zusatzfrage:

[EQ] Git speichert ja eigentlich nur Snapshots der Dateien, wie erzeugt es dann also die diff 
ausgabe?

[HINT::Ich stehe auf dem Schlauch, wo soll ich das denn finden?]
Die Ausgabe von `git diff` gibt ihnen einen entscheidenden Hinweis.

z.B.:

```diff 
diff --git a/ch/Werkzeuge/Git/git-102.md b/ch/Werkzeuge/Git/git-102.md
new file mode 100644
index 0000000..140f45f
--- /dev/null
+++ b/ch/Werkzeuge/Git/git-102.md
```

[ENDHINT]

Jetzt wo wir unsere Multiplikation vollständig implementiert haben wollen wir wieder den 
aktuellen Zustand festhalten. Fügen sie die verbleibenden Änderungen dem Index hinzu und erstellen 
Sie wieder einen Commit mit sinnvoller Nachricht. 

Schauen wir uns zuletzt noch ein weiteres nützliches Werkzeug etwas genauer an, `git log`.

`git log` ist praktisch unser Git-Tagebuch. Hier werden alle Commits festgehalten. Das ist 
insofern nützlich, als es uns ermöglicht, die Commit-Historie durchzusehen. So können wir 
beispielsweise nachvollziehen, was bestimmte Commits verändert haben, und deren jeweiligen 
Hash-Namen ermitteln. Mit diesen Hash-Namen können wir dann entweder den gesamten Working Tree oder 
einzelne Dateien auf den Zustand eines bestimmten Commits zurücksetzen.

Wenn wir jetzt einfach nur `git log` ohne irgendwelchen weiteren Argumente aufrufen, sieht 
unsere Ausgabe ungefähr so aus:

```
commit f8edd7796f5bee38a383ba131a8caebcafaceb6c (HEAD -> master)
Author: Max Mustermann <Max.Mustermann@example.com>
Date:   Tue Apr 29 15:44:36 2025 +0200

    add multiplication

commit 2a1251cf381308cf113fe3f23aedc4fb792d6365
Author: Max Mustermann <Max.Mustermann@example.com>
Date:   Tue Apr 29 15:31:51 2025 +0200

    implemented addition
```

Soweit so gut, was sehen wir hier also?

Wir sehen:
1. Den commit hash `commit 2a1251cf381308cf113fe3f23aedc4fb792d6365`
2. Den Autor `Author: Max Mustermann <Max.Mustermann@example.com>`
3. Das Datum `Date:   Tue Apr 29 15:31:51 2025 +0200`
4. Die Commit-Nachricht: `implemented addition`

Aber man kann `git log` noch erweitern. Wenn Sie möchten, schauen Sie ruhig mal in die 
Dokumentation. Dort werden Sie sicherlich *eine Menge* an Optionen finden.

Zu Beginn gibt es aber lediglich ein paar wenige Optionen die wir Ihnen mit an die Hand geben. 

Zum einen gibt es `--oneline` damit wird schlichtweg ein Commit auf eine einzelne Zeile 
reduziert. Dies kann vor allem bei ganz viel Historie hilfreich sein.

Zum anderen gibt es `-p`, dadurch wird für jeden Commit ein sogenannter patch text erzeugt. Einfach 
gesagt für jeden commit ein diff auf alle files. Streng genommen gibt es ein paar unterschiede zu 
`git diff`, welche das genau sind, können sie in der `git log` Doku nachlesen. Für unsere Zwecke 
sind die beiden Befehle in diesem fall aber vorerst mehr oder weniger synonym.

[EQ] Gibt es weitere sinnvolle optionen? Recherchieren Sie!

[NOTICE]
Gelegentlich haben Sie sicherlich schon einmal die Notation `HEAD~1` oder `HEAD^2` irgendwo 
gesehen und sich gefragt was das eigentlich zu bedeuten hat.

Dabei handelt es sich um sogenannte "ancestry references". `~` und `^` sind dabei kürzel für das 
rückwarts-traversieren der git-Historie (einsehbar über `git log`). `~` wird dabei gradlinig 
rückwärts laufen ungeachtet etwaiger abzweigungen. `^` kann dann entsprechend genutzt 
werden, wenn ein merge-Commit ins Spiel kommt, dort kann ein Commit nämlich mehrere "Elternteile" haben. 
Was es damit auf sich hat lernen Sie in [PARTREF::git-Branches]
[ENDNOTICE]

[ENDSECTION]

[SECTION::submission::trace]

[INCLUDE::/_include/Submission-Kommandoprotokoll.md]

[ENDSECTION]

[INSTRUCTOR::wir prüfen das protokoll und die abgaben der teilnehmer auf verständnis]
.
[ENDINSTRUCTOR]