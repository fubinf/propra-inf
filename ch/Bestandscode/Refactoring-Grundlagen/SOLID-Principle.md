title: Clean Code - Das SOLID-Prinzip
stage: alpha
timevalue: 1
difficulty: 3
---

TODO_pietrak:

- Hier auch bin ich der Meinung, dass ein praktisches Beispiel, an dem man im Rahmen von SOLID arbeitet, das Thema klarer machen k√∂nnte. Das k√∂nnte aber auch √ºbertrieben sein, weil es nicht einfach w√§re, so ein umfassendes Beispiel so konstruieren, ohne vom Hauptthema auszuweichen. 

- Es k√∂nnte auch hilfreich sein, √ºber m√∂gliche Nachteile zu diskutieren, die durch (√ºbertriebene) Anwendung der SOLID-Prinzipien entstehen k√∂nnten, nur um teilweise umfassenderes Verst√§ndnis zu erlangen.

PS: Falls du der Meinung w√§rest, dass man ohne die oben vorgeschlagenen Erweiterungen genug verstehen w√ºrde, dann k√∂nntest du den stage auf "beta" erh√∂hen und an Final-Review weiterleiten. 
---

[SECTION::goal::idea]

- Ich verstehe, welche Entwurfsprinzipien hinter dem Akronym SOLID stehen.
- Ich kann in eigenen Worten erkl√§ren, wie die SOLID-Entwurfsprinzipien dazu beitragen, meinen Code wartbarer und verst√§ndlicher zu gestalten.

[ENDSECTION]

[SECTION::background::default]

Kaum ein Konzept l√∂st in der Welt der Programmierer solche Glaubensk√§mpfe aus wie das Konzept von "Clean Code", also
"sauberem Code". 

[ENDSECTION]

[SECTION::instructions::detailed]

Sehen Sie sich das Video 
[Uncle Bob‚Äôs SOLID Principles Made Easy üçÄ - In Python!](https://www.youtube.com/watch?v=pTB30aXS77U)  
an.
Hier erkl√§rt ArjanCode das SOLID-Prinzip an einem einfachen Python-Skript.
Erkl√§ren Sie anschlie√üend in eigenen Worten:

- [EQ] Wof√ºr steht das Akronym SOLID?
- [EQ] Wie erzielt man die durch SOLID gew√ºnschten Effekte?
- [EQ] Welche der Prinzipien stehen im Kontext zueinander?

[ENDSECTION]

[SECTION::submission::information]

[INCLUDE::../../_include/Submission-Markdowndokument.md]

[ENDSECTION]

[INSTRUCTOR::Grundlagen SOLID]

1. **S**ingle Responsibility (Einzelne Verantwortung)
    - Mache Dinge (Klassen, Funktionen usw.) f√ºr die Erf√ºllung einer bestimmten Aufgabe verantwortlich.
      z.B. Refactoring von Code-Verantwortlichkeiten in separate Klassen.

2. **O**pen/Closed (Offen/Geschlossen)
    - F√ºge neue Funktionen einfach zu bestehendem Code hinzu, ohne den bestehenden Code zu ver√§ndern.
      z.B. Verwende abstrakte Klassen. 
      Diese k√∂nnen definieren, was Unterklassen ben√∂tigen und st√§rken Prinzip 1. durch die 
      Trennung von Codeaufgaben. 

3. **L**iskov Substitution (Liskov-Substitution)
    - Wenn eine Klasse von einer anderen Klasse erbt, 
      sollte das Programm nicht kaputtgehen und du solltest nichts hacken m√ºssen, um die 
      Unterklasse zu verwenden. 
      Definiere z.B. Konstruktorargumente, um die Vererbung flexibel zu halten.

4. **I**nterface Segregation (Schnittstellentrennung)
    - Mache Schnittstellen (√ºbergeordnete abstrakte Klassen) spezifischer statt allgemeiner.
      Beispiel: Erstelle bei Bedarf weitere Schnittstellen (Klassen) und/oder stelle den 
      Konstruktoren Objekte zur Verf√ºgung.

5. **D**ependency Inversion (Umkehrung von Abh√§ngigkeiten)
    - Mache Klassen von abstrakten Klassen abh√§ngig, anstatt von nicht-abstrakten Klassen.
      z. B. indem du Klassen von abstrakten Klassen erben l√§sst.

[ENDINSTRUCTOR]
